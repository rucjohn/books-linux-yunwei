# 进程

进程是程序执行的一个实例，进程充分描述了程序执行到何种程度的数据结构的汇集。进程的目的是担当分配系统资源的实例。

一个进程由几个线程组成，每个线程都代表进程的一个执行流。Linux 使用轻量级进程 LWP 对多线程应用程序提供更好的支持。在 Linux 中，一个线程组基本上就是实现了多线程应用的一组轻量级进程，实现了轻量级进程与每个线程的关联。

子进程对内存单元的修改对父进程是不可见的，反之亦然。

进程描述符都是 task_struct 类型结构，它的字段包含了与一个进程相关的所有信息。

## 进程状态

状态 | TASK | 缩写 | 描述
--- | --- | --- | ---
可运行状态 | TASK_RUNNING | R | 正在 CPU 中运行的，或者准备在运行的
可中断的等待状态（睡眠状态） | TASK_INTERRUPTIBLE | S | 进程被挂起（睡眠），如等待某件事件发生（等待连接、获取资源、信息量）
不可中断的等待状态 | TASK_UNINTERRUPTIBLE | D | 进程同样被挂起，但不能通过信号量来唤醒，只能等待某些特定事件发生。比如，进程需要连接外部设备，驱动程序开始探测设备时，将会出现此状态，探测完成前不可中断，否则设备会出现不可预知的情况
暂停状态 | TASK_STOPPED | T | 
跟踪状态 | TASK_TRACED | t |
僵死状态 | EXIT_ZOMBIE | Z | 子进程退出，但父进程未调用 `wait()` 或 `waitpid()` 系统调用返回有关退出进程的信息。
僵死撤消状态 | EXIT_DEAD |  | 进程真正死亡

## 进程上下文

执行在用户态的进程指令和数据在寄存器和堆栈的内容，称为进程上文；

执行在内核态的进程指令和数据在寄存器和堆栈的内容，称为进程下文；

进程上下文，一定是进程了系统调用或异常执行，导致 CPU 从用户空间切换到了内核空间。寄存器的任务状态段 TSS 用来存放进程上下文。

## 进程 ID

使用进程标识符 PID 来标记进程。默认，PID 的上限是 32767（PID_MAX_DEFAULT - 1），Linux 通过 `/proc/sys/kernel/pid_max` 文件来修改 PID 上限。

Linux 中一个线程组中所有线程都使用该组的领头线程相同的 PID，也就是该组第一个轻量级进程的 PID。它被存入进程描述符的 tgid 字段。`getpid()` 系统调用返回的 tgid 字段的值，而不是 pid 字段的值。

Linux 把内核态的进程堆栈和线程描述符 thread_info 存放在两个连续的页框中。

进程链表的头是 init_task 描述符，即是所谓的 0 进程 或 swapper 进程的描述符。init_task 的 task.prev 指向最后插入进程描述符的 tasks 字段。

类型 | 字段 | 描述
--- | --- | ---
PIDTYPE_PID | pid | 进程的ID
PIDTYPE_TGID | tgid | 线程组领头线程的PID
PIDTYPE_PGID | pqep | 进程组领头进程的PID
PIDTYPE_SID | session | 会话领头进程的PID

等待队列表示一组睡眠的进程，当某一条件条件为真时，由内核唤醒它们；由双向链表实现。

## 进程限制

每个进程都有一组相关的资源限制，限定指定进程使用的系统资源数据，称为 rlimit。

rlimit 是限制一个进程或一个用户的资源，而 cgroup 是限制一组进程的资源，它们是两套独立的机制，限制的内容几乎没有重合。一个进程即要受 rlimit 限制，也要受 cgroup 限制。

## 进程创建

轻量级进程由 `clone()` 函数创建，它负责建立新的轻量级进程的堆栈，并且调用对开发者隐藏的 `clone()` 系统调用。

传统的 `fork()` 系统调用在 Linux 中也是用 `clone()` 函数实现的。

当 `clone()` 创建子进程时，父进程和子进程暂时共享同一个用户堆栈，并且将堆栈设置为只读权限，当父进程或子进程其中一个想要修改堆栈内容时，便会报 “page fault” 缺页异常，同时触发写时复制，将原来的用户态堆栈拷贝一份新的，并重新设备它们的映射关系，同时将两个用户态堆栈设置为可读写权限。

为什么要用到写时复制？  
1. 加速子进程的复制
2. 减少进程对物理内存的使用

所有进程的祖先是进程 0（也叫 idle/swapper 进程）。


